Задание:
создать два однонаправленных списка затем из элементов обоих списков на овнове первого посторить список упорядоченный по возрастанию и распечатаеть его элементы
Код:
program Project17;

{$APPTYPE CONSOLE}

uses
SysUtils;
type
PTSetOfTask = ^TSetOfTask;

TDataOfTask = record
id:integer;
end;

TSetOfTask = record
next: PTSetOfTask;
data: TDataOfTask;

end;

var
PFirstTask,Psecondtask,buf1,buf2,buf3,PThirtTask: PTSetOfTask;
count:integer;
buf:TDataOfTask;

{процедура формирования неупорядоченного списка}
procedure AddInTasks(src: TDataOfTask; var base: PTSetOfTask);
var
buf: PTSetOfTask;
begin
if (base = nil) then
begin

new(base);
base^.data := src;
base^.next := nil;
end
else
begin
buf := PFirsttask;
while (buf^.next <> nil) do
buf := buf^.next;
new(buf^.next);

buf := buf^.next;
buf^.data := src;
buf^.next := nil;

end;
end;

procedure AddInSet2(src: TDataOfTask; var base: PTSetOfTask); // формируем упорядоченный, первый элемент пустой для удобства.
//основан на том, что мы ищем нужное место вставки и таким образом получаем отстортированный массив
var
buf: PTSetOfTask;
p0, p: PTSetOfTask;
begin

if (base = nil) then
begin
new(base);
base^.next := nil;
end;

new(p0);
p0^.next := nil;
p := base;
p0^.data := src;
while (p^.next <> nil) and (p0^.data.id>p^.next^.data.id) do
p := p^.next;

p0^.next := p^.next;
p^.next := p0;

end;

var
i:integer;
flag:boolean;

begin
writeln ('Ввведите кол-вол элементов в 1-ом списке') ;
readln(count);

//обнуляем головы
PFirstTask:=nil;
PSecondTask:=nil;
PThirtTask:=nil;

//ввводим
for i := 1 to count do
begin
readln(buf.id);
addintasks(buf,PFirstTask);
end;

writeln ('Ввведите кол-вол элементов в 2-ом списке') ;
readln(count);

for i := 1 to count do
begin
readln(buf.id);
addintasks(buf,PThirtTask);
end;

buf1:=PFirstTask;
//добавляем из 1-го списка
while (buf1<>nil) do
begin
addinset2(buf1.data,psecondtask);
buf1:=buf1^.next;
end;

//добавляем из 2-го списка
buf1:=PThirtTask;
while (buf1<>nil) do
begin
addinset2(buf1.data,psecondtask);
buf1:=buf1^.next;
end;

buf1:=PSecondtask^.next;
writeln('Вывод сорт списка');
//выводим
while (buf1<>nil) do
begin
write(buf1^.data.id:3);

buf1:=buf1^.next;
end;

readln;
end.

Задание:
создать два однонаправленных списка.затем оставить в первом списке только элементы,входящие в оба списка,и распечатать его элемент
код:
rogram Project17;

{$APPTYPE CONSOLE}

uses
SysUtils;
type
PTSetOfTask = ^TSetOfTask;

TDataOfTask = record
id:integer;
end;

TSetOfTask = record
next: PTSetOfTask;
data: TDataOfTask;

end;

var
PFirstTask,Psecondtask,buf1,buf2: PTSetOfTask;
count:integer;
buf:TDataOfTask;

procedure AddInTasks(src: TDataOfTask; var base: PTSetOfTask);
var
buf: PTSetOfTask;
begin
if (base = nil) then
begin

new(base);
base^.data := src;
base^.next := nil;
end
else
begin
buf := PFirsttask;
while (buf^.next <> nil) do
buf := buf^.next;
new(buf^.next);

buf := buf^.next;
buf^.data := src;
buf^.next := nil;

end;
end;

procedure AddInTask(src: TDataOfTask; var base: PTSetOfTask);
var
buf: PTSetOfTask;
begin
if (base = nil) then
begin

new(base);
base^.data := src;
base^.next := nil;
end
else
begin
buf := Psecondtask;
while (buf^.next <> nil) do
buf := buf^.next;
new(buf^.next);

buf := buf^.next;
buf^.data := src;
buf^.next := nil;

end;
end;

procedure DelTasks(var base: PTSetOfTask; id: integer);
var
buf, temp: PTSetOfTask;

begin
if (base^.data.id = id) then
begin
buf := base;
base := base^.next;
dispose(buf);
end
else
begin
buf := base;
while (buf^.next^.data.id <> id) do
begin
buf := buf^.next;

end;
temp := buf^.next;
buf^.next := buf^.next^.next;
buf := buf^.next;
dispose(temp);
end;
end;
var
i:integer;
flag:boolean;

begin
writeln ('Ввведите кол-вол элементов в массиве') ;
readln(count);
PFirstTask:=nil;
PSecondTask:=nil;
for i := 1 to count do
begin
readln(buf.id);
addintasks(buf,PFirstTask);
end;

writeln ('Второй массив. Кол-во элементов?') ;
readln(count);
//Psecondtask

for i := 1 to count do
begin
readln(buf.id);
addintask(buf,PSecondTask);
end;

buf1:=PFirstTask;
while (buf1<>nil) do
begin
buf2:=PSecondtask;
flag:=false;
while (buf2<>nil) do
begin
if (buf2^.data.id=buf1^.data.id) then
begin
flag:=true;
end;
buf2:=buf2^.next;

end;
if (not flag) then

deltasks(pfirsttask,buf1^.data.id);

buf1:=buf1^.next;
end;

buf1:=PFirstTask;
writeln('Вывод списка 1 после удаления дубликатов');
while (buf1<>nil) do
begin
write(buf1^.data.id:3);

buf1:=buf1^.next;
end;

readln;
end.

Задание(даже не запускал, но идея такая. Хотя применять обход тут не есть хорошо):
вводим с клавиатуры массив из чисел. и все дубликаты, повторы выводим на экран
Код:
program Project17;

{$APPTYPE CONSOLE}


uses
SysUtils;

TYPE
PTree = ^Tree;
Tree = record
data:Integer;
left,right:PTree;
end;

var
count,i,id:integer;
arrofelement:array of integer;
root:PTree;
flag:boolean;

function CheckElement:boolean;
begin

end;

procedure Add(var Element:PTree; inf:Integer);
begin
if Element=nil then
begin
New(Element);
Element^.data:=inf;
Element^.left:=nil;
Element^.right:=nil;
end
else
if inf<=Element^.data then Add(Element^.left,inf)
else Add(Element^.right,inf);
end;
Procedure prym_print(t: ptree);
Begin
if t<> nil then
Begin

if (t^.data=id) then
begin
flag:=true;
exit;
end;
prym_print(t^.left);
prym_print(t^.right);
End;
End;

begin
writeln ('Ввведите кол-вол элементов в массиве') ;
readln(count);

setlength(arrofelement,count);

for i := 0 to count-1 do
begin
readln( arrofelement[i] );
add(root,arrofelement[i]);
end;
flag:=false;
for i := 0 to count-1 do
begin
prym_print(prym_print);
if (flag) then
writeln ('Дубликат ',arrofelement);
flag:=false;
end;

readln;
end.

Задание (опять, даже не запускал)
найти поддерево с максимальным суммарным весом (считать и корень)
//рядом с exe должен быть txt c последовательностью для построения БД
код:
program Project13;

{$APPTYPE CONSOLE}

uses
SysUtils;

type
ss=^rec;
rec=record
data:integer;
ltag,rtag:boolean;
left,right:ss
end;
massive=array[1..1000] of integer;

var
mn:set of 1..100;
mns:set of 1..100;
mnss:set of 1..100;
number,local,z,buf,i:integer;
letter:char;
root,head,p,y:ss;

ArrOfUzl,arrofuzlobr:array of integer;
index,index1,max1,max2,sum:integer;
f:text;

procedure printtree(temp:ss; h:integer);
var
i:integer;
begin
if temp<>nil
then
with temp^ do
begin
printtree(right,h+4);
for i:=1 to h do
write(' ');
writeln(data:30);
printtree(left,h+4)
end;
end;

procedure directdetour(temp:ss);
begin
if temp = nil then write(0, ' ')
else begin
if temp^.data in mn then //write(temp^.data,' ')
else begin sum:=sum+temp^.data end;
directdetour(temp^.left);

write(temp^.data, ' ');

directdetour(temp^.right);
if temp^.data in mn then// write(temp^.data,' ')
else begin sum:=sum+temp^.data end;
end;
end;

procedure backdetour(temp:ss);
begin
if temp= nil then write(0,' ')
else
begin
write(temp^.data,' ');
backdetour(temp^.left);
write(temp^.data,' ');
backdetour(temp^.right);
if temp^.data in mns then write(temp^.data,' ')
else begin mns:=mns+[temp^.data]; write(temp^.data,'* '); end;
end;
end;

procedure symmetricaldetour1(temp:ss);
begin
begin
if temp= nil then write(0,' ')
else
begin
write(temp^.data,' ');
symmetricaldetour1(temp^.left);
if temp^.data in mnss then write(temp^.data,' ')
else begin mnss:=mnss+[temp^.data]; write(temp^.data,'* '); end;
write(temp^.data,' ');
symmetricaldetour1(temp^.right);

end;
end;
{ symmetricaldetour1(temp^.left);
write(' ',temp^.data,' ');
symmetricaldetour1(temp^.right);
end;}

end;
procedure symmetricaldetour(temp:ss);
procedure insertion(var p:ss);
begin
if y<>nil
then
if y^.right=nil
then
begin
y^.rtag:=false;
write(' ',y^.data,'->',p^.data,' ');
y^.right:=p
end
else
begin
y^.rtag:=true
end;
y:=p;
end;
begin
if temp<>nil
then
begin
symmetricaldetour(temp^.left);
insertion(temp);
symmetricaldetour(temp^.right);
end;
end;
procedure insert(var temp:ss; n:integer);
begin
if temp=nil
then
begin
new(temp);
with temp^ do
begin
data:=n;
left:=nil;
right:=nil;
end;
end
else
if n<temp^.data
then
insert(temp^.left,n)
else
insert(temp^.right,n);
end;

begin
assignfile(f,'tree.txt');
letter:='y';
root:=nil;
new(head);
head^.left:=root;
head^.right:=head;
p:=head^.left;
index:=0;
while letter='y' do
begin
reset(f);
writeln('enter the number of members:');
readln(number);
setlength(arrofuzl,number);
setlength(arrofuzlobr,number);
//arrofuzlobr
root:=nil;
y:=nil;
for z:=1 to number do
begin
read(f,local);
insert(root,local);
end;
writeln(' tree:');
printtree(root,0);
writeln('direct detour:');
directdetour(root);
writeln;
writeln('back detour:');
backdetour(root);
writeln;
index1:=0;
arrofuzlobr[number-1]:=arrofuzl[0];
max1:=0;
max2:=0;
sum:=0;
//анализируем левое поддерево
directdetour(root^.left);
max1:=sum+root^.data;
sum:=0;
directdetour(root^.right);
max2:=sum+root^.data;

if (max1>=max2) then
begin
writeln ('Сумма максимальная ',max1);
printtree(root^.left);
end
else
begin
writeln ('Сумма максимальная ',max1);
printtree(root^.right);
end;

writeln('continue? (Y/N)');
readln(letter);
close(f);
end;
readln
end.

Задача://читерство
построить очередь упорядочить её по убыванию затем вставить в очередб эелемент k не нарушив порядок очереди
12:39	
Артём
КОд

	
program r32423423423;

{$APPTYPE CONSOLE}

uses
SysUtils;
type

PTSetOfTask = ^TSetOfTask;

TDataOfTask = record
id:integer;
end;
TSetOfTask = record
next: PTSetOfTask;
data: TDataOfTask;
end;
var
PFirstTask,Psecondtask,buf1,buf2: PTSetOfTask;
count:integer;
buf:TDataOfTask;
procedure AddInTasks(src: TDataOfTask; var base: PTSetOfTask); // neypor9d spisok
var
buf: PTSetOfTask;
begin
if (base = nil) then
begin
new(base);
base^.data := src;
base^.next := nil;
end
else
begin
buf := PFirsttask;
while (buf^.next <> nil) do
buf := buf^.next;
new(buf^.next);
buf := buf^.next;
buf^.data := src;
buf^.next := nil;
end;
end;
procedure AddInTask(src: TDataOfTask; var base: PTSetOfTask);
var
buf: PTSetOfTask;
begin
if (base = nil) then
begin
new(base);
base^.data := src;
base^.next := nil;
end
else
begin
buf := Psecondtask;
while (buf^.next <> nil) do
buf := buf^.next;
new(buf^.next);
buf := buf^.next;
buf^.data := src;
buf^.next := nil;
end;
end;
procedure AddInSet2(src: TDataOfTask; var base: PTSetOfTask); // ypor9d sp, pervii pystoi
//is4em nyjnoe mesto dl9 vstavki
var
buf: PTSetOfTask;
p0, p: PTSetOfTask;
begin
if (base = nil) then
begin
new(base);
base^.next := nil;
end;
new(p0);
p0^.next := nil;
p := base;
p0^.data := src;
while (p^.next <> nil) and (p0^.data.id<p^.next^.data.id) do
p := p^.next;
p0^.next := p^.next;
p^.next := p0;
end;
var
i:integer;
flag:boolean;
begin
writeln ('vvedite kol-vo v o4eredi') ;
readln(count);
//golovi 0
PFirstTask:=nil;
PSecondTask:=nil;
writeln ('vvedite vesa dl9 kajdogo') ;
//vvodim
for i := 1 to count do
begin
readln(buf.id);
addintasks(buf,PFirstTask);
end;
buf1:=PFirstTask;
//vtoroi otsort sp
while (buf1<>nil) do
begin
addinset2(buf1.data,psecondtask);
buf1:=buf1^.next;
end;
writeln('o4ered` po ybivaniu');
//vivodim
buf1:=PSecondtask^.next;
while (buf1<>nil) do
begin
write(buf1^.data.id:3);
buf1:=buf1^.next;
end;
writeln('dobavim v konec ne naryshiv por9dok');
readln(buf.id);
addinset2(buf,psecondtask);
writeln('vivod o4eredi posle dobavleni9 elemnta v konec');
//vivodim
buf1:=PSecondtask^.next;
while (buf1<>nil) do
begin
write(buf1^.data.id:3);
buf1:=buf1^.next;
end;
readln;
end.