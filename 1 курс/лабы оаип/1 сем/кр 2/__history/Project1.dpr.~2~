program kr2;

uses
    SysUtils,
    Math;

type
    TArr = array[1..100] of Integer;

{function GetMaxOrder(DataArray: TIntArray): Integer;
var
   i: Byte;
   MaxEl: Integer;
begin
   MaxEl := DataArray[0];
   for i := 1 to High(DataArray) do
      if DataArray[i] > MaxEl then
         MaxEl := DataArray[i];
   GetMaxOrder := Length(IntToStr(MaxEl));
end;}

procedure RadixSort(N: Byte; var DataArr: TArr);
var
    i, j, k: Byte;
    PosArr: array [0 .. 9] of array of Integer;
    TempArray: TIntArray;
    Dev: Integer;
    MaxOrder: Integer;
begin
    MaxOrder := GetMaxOrder(DataArr);
    Dev := 1;
    Setlength(TempArray, Length(DataArr));
    repeat
        for i := 0 to High(DataArr) do
        begin
            Setlength(PosArr[(DataArr[i] div Dev) mod 10],
                Length(PosArr[(DataArr[i] div Dev) mod 10]) + 1);
            PosArr[(DataArr[i] div Dev) mod 10]
                [ High(PosArr[(DataArr[i] div Dev) mod 10])] := i;
        end;
        Dev := Dev * 10;
        k := 0;
        for i := 0 to High(PosArr) do
            if Length(PosArr[i]) <> 0 then
            begin
                for j := 0 to High(PosArr[i]) do
                begin
                    TempArray[k] := DataArr[PosArr[i][j]];
                    Inc(k);
                end;
                Setlength(PosArr[i], 0);
            end;
        for i := 0 to High(DataArr) do
            DataArr[i] := TempArray[i];
    until Dev = Power(10, MaxOrder);
    RadixSort := DataArr;
end;

var
   Arr: TArr;
   i, N: Integer;
begin
   Write('N: ');
   ReadLn(N);
   for i := 1 to N do
      Read(Arr[i]);
   RadixSort(N, Arr);
   for i := 1 to N do
      Write(Arr[i], ' ');
   Readln;
end.
